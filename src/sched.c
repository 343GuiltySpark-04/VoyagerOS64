#include <stdint.h>
#include "include/printf.h"
#include "include/liballoc.h"
#include "include/sched.h"
#include "include/lock.h"
#include "include/gdt.h"
#include "include/pic.h"
#include "include/string.h"
#include <stdbool.h>

#define SAVE_STATE()                       \
    asm volatile("pushq %rax");            \
    asm volatile("pushq %rcx");            \
    asm volatile("pushq %rdx");            \
    asm volatile("pushq %rbx");            \
    asm volatile("pushq %rsp");            \
    asm volatile("pushq %rbp");            \
    asm volatile("pushq %rsi");            \
    asm volatile("pushq %rdi");            \
    asm volatile("pushq %r8");             \
    asm volatile("pushq %r9");             \
    asm volatile("pushq %r10");            \
    asm volatile("pushq %r11");            \
    asm volatile("pushq %r12");            \
    asm volatile("pushq %r13");            \
    asm volatile("pushq %r14");            \
    asm volatile("pushq %r15");            \
    asm volatile("movq %cr3, %rax");       \
    asm volatile("movq %rax, %cr3");       \
    asm volatile("movq %cr0, %rax");       \
    asm volatile("orq $0x80000000, %rax"); \
    asm volatile("movq %rax, %cr0");       \
    asm volatile("ltr %ax"                 \
                 :                         \
                 : "a"(TSS_SELECTOR));

bool timer_fired = false;

bool sched_started = false;

static spinlock_t schedlock_t = SPINLOCK_INIT;

const uint64_t quantum = 10;

const uint64_t quantum_limit = 50;
extern halt();

/**
 * @brief Create a new process with the given parameters
 * @param id ID of the process to create
 * @param priority Priority of the process to create
 * @param mortality Whether or not to mortal the process
 * @param name [ 256 ]
 * @return Pointer to the newly created
 */
struct Process create_process(uint64_t id, uint64_t priority, bool mortality, char name[256])
{

    struct Process p;

    for (int i = 0; i < 256; i++){

        p.name[i] = name[i];

    }

    uint64_t pid = (uint64_t)pid_hash(name);

    p.priority = priority;
    p.allocated_time = 0;
    p.immortal = mortality;
    p.id = pid;

    return p;
}

// Generate a PID from hashing the process name
/**
 * @brief This function hashes a name using FNV
 * @param name [ 256 ]
 * @return A 64 - bit hash
 */
uint64_t pid_hash(char name[256])
{

    uint64_t input = str2int2(&name);

    // Use the FNV-1a algorithm to generate a 64-bit hash value for the input
    const uint64_t FNV_PRIME = 16777619;
    const uint64_t FNV_OFFSET_BASIS = 0x811c9dc5;
    uint64_t hash = FNV_OFFSET_BASIS;
    for (int i = 0; i < sizeof(input); i++)
    {
        hash ^= (input & 0xff); // XOR with lower 8 bits of input 
        input >>= 8; // Shift right by 8 bits 
        hash *= FNV_PRIME; // Multiply by prime number 
    } 

    return hash; 
}



// Function to add a new process to the scheduler
/**
 * @brief Add a process to the end of the list
 * @param * scheduler
 * @param p Pointer to the process to
 */
void add_process(struct Scheduler *scheduler, struct Process p)
{
    // Increase size of array to store processes
    scheduler->processes = realloc(scheduler->processes, ++scheduler->n * sizeof(struct Process));

    // Add new process to the end of the array
    scheduler->processes[scheduler->n - 1] = p;

    scheduler->current_process++;
}

// Function to remove a process from the scheduler
/**
 * @brief Remove a process from the list
 * @param * scheduler
 * @param id ID of the process to be removed
 * @return void Removal is done in - place
 */
void remove_process(struct Scheduler *scheduler, uint64_t id)
{
    // Find the index of the process to be removed
    int index = -1;
    for (int i = 0; i < scheduler->n; i++)
    {
        if (scheduler->processes[i].id == id)
        {
            index = i;
            break;
        }
    }

    // Return if process is not found
    if (index == -1)
        return;

    // Shift all subsequent processes one position to the left
    for (int i = index; i < scheduler->n - 1; i++)
        scheduler->processes[i] = scheduler->processes[i + 1];

    scheduler->current_process--;

    scheduler->processes = realloc(scheduler->processes, --scheduler->n * sizeof(struct Process));
}

// Function to perform scheduling
/**
 * @brief Schedules a process to run.
 * @param * scheduler
 * @param time_quantum Time in milliseconds to reserve
 */
void schedule(struct Scheduler *scheduler, uint64_t time_quantum)
{
    pic_mask_irq(0);
    // Check if an interrupt has been generated by the PIT

    printf_("%s", "The size of the processes array is: ");
    printf_("%u\n", sizeof(scheduler->processes));

    if (timer_fired == true)
    {
        // Allocate CPU time to the current process
        struct Process *current = &scheduler->processes[scheduler->current_process];
        current->allocated_time += time_quantum;

        // If the current process has been allocated enough time, rotate the processes in the scheduler
        if (current->allocated_time >= quantum_limit)
        {

            // Rotate the processes in the scheduler
            for (int i = 0; i < scheduler->n - 1; i++)
                scheduler->processes[i] = scheduler->processes[i + 1];
            scheduler->processes[scheduler->n - 1] = *current;

            // Reset the allocated time for the current process
            current->allocated_time = 0;
        }

        /*        // Check if the current process is requesting a syscall
               if (current->request_syscall)
               {
                   // Handle the syscall request
                   handle_syscall(current);

                   // Reset the syscall request flag
                   current->request_syscall = 0;
               }
        */
        // Reset the interrupt generated flag
        timer_fired = false;
    }

    printf_("%s\n", "succes");

    pic_unmask_irq(0);
}

// Global variable to store the next available ID
uint64_t next_id = 2;

// Function to generate a seed ID
/**
 * @brief Generates a new ID for the object
 * @return The ID of the new
 */
uint64_t generate_id()
{
    // Get the next available ID
    uint64_t id = next_id;

    // Increment the next available ID
    next_id++;

    // Return the new ID
    return id;
}

// Function to create a new child process
/**
 * @brief Fork a process from the current process
 * @param * scheduler
 */
void fork(struct Scheduler *scheduler)
{

    uint64_t parent_id = scheduler->processes[scheduler->current_process - 1].id;
    uint64_t parent_index = scheduler->current_process - 1;
    char parent_name;

    parent_name = scheduler->processes[parent_index].name;

    // Create a new process with the the ID being a hash generated from the parent PID
    uint64_t id = pid_hash(parent_id);
    if (id == scheduler->processes[parent_index].id)
    {

        id++;
    }
    printf_("Parent ID: %u\n", parent_id);
    printf_("Child ID: %u\n", id);
    struct Process child = create_process(id, 2, false, parent_name);

    // Add the new process to the scheduler
    add_process(scheduler, child);
}

// Function to exit the current process
/**
 * @brief This function is called when the scheduler is shutting down.
 * @param * scheduler
 * @return Returns nothing. The scheduler must be stopped
 */
void exit(struct Scheduler *scheduler)
{
    // Get the ID of the current process
    int id = scheduler->processes[scheduler->current_process].id;

    // Check if the immortal flag is present
    bool flag = scheduler->processes[0].immortal;
    if (flag == true)
    {

        // spinlock_acquire(&schedlock_t);

        printf_("%s\n", "ERROR: ATEMPT TO TERMINATE A CORE SYSTEM THREAD! ABORTING EXIT!");
        printf_("%s", "Current PID: ");
        printf_("%i\n", id);

        return;
    }

    // Remove the current process from the scheduler
    remove_process(scheduler, id);

    // printf_("%s\n", "DONE");

    return;
}
