#include <stdint.h>
#include "include/printf.h"
#include "include/liballoc.h"
#include "include/sched.h"
#include "include/lock.h"
#include "include/gdt.h"
#include "include/pic.h"
#include "include/string.h"
#include <stdbool.h>

#define SAVE_STATE()                       \
    asm volatile("pushq %rax");            \
    asm volatile("pushq %rcx");            \
    asm volatile("pushq %rdx");            \
    asm volatile("pushq %rbx");            \
    asm volatile("pushq %rsp");            \
    asm volatile("pushq %rbp");            \
    asm volatile("pushq %rsi");            \
    asm volatile("pushq %rdi");            \
    asm volatile("pushq %r8");             \
    asm volatile("pushq %r9");             \
    asm volatile("pushq %r10");            \
    asm volatile("pushq %r11");            \
    asm volatile("pushq %r12");            \
    asm volatile("pushq %r13");            \
    asm volatile("pushq %r14");            \
    asm volatile("pushq %r15");            \
    asm volatile("movq %cr3, %rax");       \
    asm volatile("movq %rax, %cr3");       \
    asm volatile("movq %cr0, %rax");       \
    asm volatile("orq $0x80000000, %rax"); \
    asm volatile("movq %rax, %cr0");       \
    asm volatile("ltr %ax"                 \
                 :                         \
                 : "a"(TSS_SELECTOR));

bool timer_fired = false;

bool sched_started = false;

static spinlock_t schedlock_t = SPINLOCK_INIT;

const uint64_t quantum = 10;

const uint64_t quantum_limit = 50;

extern halt();

// Function to create a new process
struct Process create_process(uint64_t id, uint64_t priority, bool mortality, char name[256])
{

    struct Process p;

    p.name[256] = name;

    uint64_t pid = pid_hash(name);

    p.priority = priority;
    p.allocated_time = 0;
    p.immortal = mortality;
    p.id = pid;

    return p;
}

// Generate a PID from hashing the process name
uint64_t pid_hash(char name[256])
{

    uint64_t input = str2int(name);

    // Use the FNV-1a algorithm to generate a 64-bit hash value for the input
    const uint64_t FNV_PRIME = 1099511628211;
    const uint64_t FNV_OFFSET_BASIS = 14695981039346656037;
    uint64_t hash = FNV_OFFSET_BASIS;
    for (int i = 0; i < sizeof(input); i++)
    {
        hash ^= (input >> (i * 8));
        hash *= FNV_PRIME;
    }
    return hash;
}

// Function to add a new process to the scheduler
void add_process(struct Scheduler *scheduler, struct Process p)
{
    // Increase size of array to store processes
    scheduler->processes = realloc(scheduler->processes, ++scheduler->n * sizeof(struct Process));

    // Add new process to the end of the array
    scheduler->processes[scheduler->n - 1] = p;

    scheduler->current_process++;
}

// Function to remove a process from the scheduler
void remove_process(struct Scheduler *scheduler, uint64_t id)
{
    // Find the index of the process to be removed
    int index = -1;
    for (int i = 0; i < scheduler->n; i++)
    {
        if (scheduler->processes[i].id == id)
        {
            index = i;
            break;
        }
    }

    // Return if process is not found
    if (index == -1)
        return;

    // Shift all subsequent processes one position to the left
    for (int i = index; i < scheduler->n - 1; i++)
        scheduler->processes[i] = scheduler->processes[i + 1];

    scheduler->processes = realloc(scheduler->processes, --scheduler->n * sizeof(struct Process));

    scheduler->current_process--;
}

// Function to perform scheduling
void schedule(struct Scheduler *scheduler, uint64_t time_quantum)
{
    pic_mask_irq(0);
    // Check if an interrupt has been generated by the PIT

    printf_("%s", "The size of the processes array is: ");
    printf_("%u\n", sizeof(scheduler->processes));

    if (timer_fired == true)
    {
        // Allocate CPU time to the current process
        struct Process *current = &scheduler->processes[scheduler->current_process];
        current->allocated_time += time_quantum;

        // If the current process has been allocated enough time, rotate the processes in the scheduler
        if (current->allocated_time >= quantum_limit)
        {

            // Rotate the processes in the scheduler
            for (int i = 0; i < scheduler->n - 1; i++)
                scheduler->processes[i] = scheduler->processes[i + 1];
            scheduler->processes[scheduler->n - 1] = *current;

            // Reset the allocated time for the current process
            current->allocated_time = 0;
        }

        /*        // Check if the current process is requesting a syscall
               if (current->request_syscall)
               {
                   // Handle the syscall request
                   handle_syscall(current);

                   // Reset the syscall request flag
                   current->request_syscall = 0;
               }
        */
        // Reset the interrupt generated flag
        timer_fired = false;
    }

    printf_("%s\n", "succes");

    pic_unmask_irq(0);
}

// Global variable to store the next available ID
uint64_t next_id = 2;

// Function to generate a seed ID
uint64_t generate_id()
{
    // Get the next available ID
    uint64_t id = next_id;

    // Increment the next available ID
    next_id++;

    // Return the new ID
    return id;
}

// Function to create a new child process
void fork(struct Scheduler *scheduler)
{

    uint64_t parent_id = scheduler->processes[scheduler->current_process - 1].id;
    uint64_t parent_index = scheduler->current_process - 1;
    char parent_name;

    parent_name = scheduler->processes[parent_index].name;

    // Create a new process with the the ID being a hash generated from the parent PID
    uint64_t id = pid_hash(parent_id);
    if (id == scheduler->processes[parent_index].id)
    {

        id++;
    }
    printf_("Parent ID: %u\n", parent_id);
    printf_("Child ID: %u\n", id);
    struct Process child = create_process(id++, 2, false, parent_name++);

    // Add the new process to the scheduler
    add_process(scheduler, child);
}

// Function to exit the current process
void exit(struct Scheduler *scheduler)
{
    // Get the ID of the current process
    int id = scheduler->processes[scheduler->current_process].id;

    // Check if the immortal flag is present
    bool flag = scheduler->processes[0].immortal;
    if (flag == true)
    {

        // spinlock_acquire(&schedlock_t);

        printf_("%s\n", "ERROR: ATEMPT TO TERMINATE A CORE SYSTEM THREAD! ABORTING EXIT!");
        printf_("%s", "Current PID: ");
        printf_("%i\n", id);

        return;
    }

    // Remove the current process from the scheduler
    remove_process(scheduler, id);

    // printf_("%s\n", "DONE");

    return;
}
